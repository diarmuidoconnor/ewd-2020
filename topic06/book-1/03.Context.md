
## GlobalState and Contexts.

A common feature of React apps is part of its state is required by many components. This can lead to 'prop drilling', where components in the middle of the component hierarchy transmit props from high-level components to low-level components. The intermediate components do not use the props themselves. The current authenticated user is an example of this case.

Another common implementation weakness is when a component requests API data every time it mounts, even though the data is unchanged. This case arises in our app in relation to the list of movies and the list of genres. The genres never change, while the movie list may change between app runs but not during a single execution session.

### The Movie list context.

Create the file `src/contexts/moviesContext.js`:
~~~
import React, { useState, useEffect } from "react";
import StubAPI from "../api/stubAPI";
import { getMovies } from "../api/tmdb-api";

export const MoviesContext = React.createContext(null)

const MoviesContextProvider = props => {
  const [movies, setMovies] = useState([]);

  const addToFavorites = movieId => {
    setMovies(movies => {
      const index = movies.map(m => m.id).indexOf(movieId);
      StubAPI.add(movies[index]);
      movies.splice(index, 1);
      return [...movies];
    });
  };
  useEffect(() => {
    getMovies().then(movies => {
      setMovies(movies);
    });
  }, []);

  return (
    <MoviesContext.Provider
      value={{
        movies: movies,
        addToFavorites: addToFavorites
      }}
    >
      {props.children}
    </MoviesContext.Provider>
  );
};

export default MoviesContextProvider
~~~

The MoviesContextProvider component now manages the loading and modifying (addToFavorites) of the movie list. It uses component composition (props.children), which allows us merge with other components that reference movies. The JSX indicates the *context provider* quality of MoviesContextProvider; i.e. MoviesContext.Provider. It means other components will be have access to the movies array and addToFavorites function.

In `src/index.js` add an import:
~~~
import MoviesContextProvider from "./contexts/moviesContext";
~~~
and modify the App component:
~~~
const App = () => {
  return (
    <MoviesContextProvider>
      <BrowserRouter>
        . . . . as before . . . . 
      </BrowserRouter>
    </MoviesContextProvider>
~~~

This is the other side of the component composition pattern used by MoviesContextProvider.
This change means all components in our app can now access the provider's object, subject to a small code addition. In particular, `pages/homePage.js` needs to access the movies list. In fact most of its functionality has moved to the the context provider. Completely replace its code with the following:
~~~
import React, { useContext } from "react";
import PageTemplate from '../components/templateMovieListPage'
import {MoviesContext} from '../contexts/moviesContext'

const MovieListPage = () => {
  const context = useContext(MoviesContext);

  return (
      <PageTemplate 
        title='All Movies'
        movies={context.movies}
        buttonHandler={context.addToFavorites}
      />
  );
};

export default MovieListPage;
~~~
The line:
~~~
  const context = useContext(MoviesContext);
~~~
allows the above component access any value exposed by the context, e.g.
~~~
context.movies
and
context.addToFavorites
~~~

In the browser check the home page and exercise the add to favorites feature. The bug identified earlier is also fixed by these changes. Try the following:

1. Go to the homepage and refresh the page.
1. Click the 'Add to favorites' button of the first three movies, leaving 17 in the list.
1. The selected movies are removed from the home page, as expected. 
1. Navigate to the Favorites page.
1. Navigate back to the Home page. It still has only 17 movies. The app did not re-request the full list of movies from the API.

### The Genre list context.

Create the file `src/contexts/genresContext.js`:
~~~
import React, { useState, useEffect, createContext } from "react";
import { getGenres } from "../api/tmdb-api";

export const GenresContext = createContext(null)

const GenresContextProvider = props => {
    const [genres, setGenres] = useState([{ id: "0", name: "All" }]);
    useEffect(() => {
      getGenres().then(allGenres => {
        setGenres([genres[0], ...allGenres]);
      });
    }, []);

    return (
        <GenresContext.Provider
          value={{
            genres
          }}
        >
          {props.children}
        </GenresContext.Provider>    
    )
}

export default GenresContextProvider;
~~~

This context is only required (for now) by the FilterControls component - it's more targeted. In `src/components/templateMoviesListPage.js` add an import:
~~~
import GenresContextProvider from "../../contexts/genresContext";
~~~
and compose the context provider with FilterControls:
~~~
  return (
    <>
      . . . as before . . .
      <GenresContextProvider>
        <FilterControls
          onUserInput={handleChange}
          numMovies={displayedMovies.length}
        />
      </GenresContextProvider>
      . . . as before . . .
    </>
  );
~~~
Finally, in `compoonents/filterControls/index.js` replace the content with the following:
~~~
import React, { useContext } from "react";
import "./filterControls.css";
import { GenresContext } from '../../contexts/genresContext' 

const FilterControls = props => {
  const context = useContext(GenresContext);

  const handleChange = (e, type, value) => {
    e.preventDefault();
    props.onUserInput(type, value);
  };
  const handleTextChange = e => {
    handleChange(e, "name", e.target.value);
  };
  const handleGenreChange = e => {
    handleChange(e, "genre", e.target.value);
  };

  return (
    <div className="row bg-warning">
      <div className="col-md-12">
        <h4>
          <span>List Filtering:</span>
          <input
            type="text"
            placeholder="Title Search"
            onChange={handleTextChange}
          />
          <span>Genre:</span>
          <select id="genre" onChange={handleGenreChange}>
            {context.genres.map(genre => {
              return (
                <option key={genre.id} value={genre.id}>
                  {genre.name}
                </option>
              );
            })}
          </select>
        </h4>
      </div>
    </div>
  );
};

export default FilterControls;
~~~
What has changed?

1. The useState and useEffect code has moved to the context provider.
1. The Select dropdown is populated by entries from the context.

Before continuing, from the integrated terminal panel, update the git repository, as follows:
~~~
$ git add -A
$ git commit -m "Movie list and genres now managed by contexts"
~~~
